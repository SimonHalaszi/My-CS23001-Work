/*
* Simon Halaszi
* string project
* CS23001
*/

// string.cpp for milestone 1

#include "stringM1.hpp"
#include <cassert>

// Empty string
String::String() {
    str[0] = '\0';
}

// String('x')
String::String(char ch) {
    str[0] = ch;
    str[1] = '\0';
}

// String("abcd")
String::String(const char cString[]) {
    int i = 0;
    while(cString[i] != '\0') {
        
        // Assertion to prevent making strings larger than the capacity.
        // assert(i != capacity());
        
        str[i] = cString[i];
        ++i;
    }
    str[i] = '\0';
}

// Max chars that can be stored
int String::capacity() const {
    return STRING_SIZE - 1;
}

// Number of char in string
int String::length() const {
    int i = 0;
    while(str[i] != '\0') {
        ++i;
    }
    return i;
}

// Accessor
char String::operator[](int index) const {  
    // assert(index <= length());
    return str[index];
}

// Modifier
char& String::operator[](int index) {
    // assert(index <= length());
    return str[index];
}

// Concatenation
String& String::operator+=(const String& rhs) {
    int len = length();
    int rhsLen = rhs.length();

    // Assertion to prevent concatenating onto full strings
    // assert(length() + rhs.length() <= capacity());
    
    int i = len;
    while(i - len < rhsLen) {
        str[i] = rhs.str[i - len];
        ++i;
    }
    str[i] = '\0';
    return *this;
}   

bool String::operator==(const String& rhs) const {
    int i = 0;
    while(str[i] == rhs.str[i] && str[i] != '\0' && rhs.str[i] != '\0') {
        ++i;
    }
    return (str[i] == rhs.str[i]);
}

bool String::operator<(const String& rhs) const {
    int i = 0;
    while(str[i] == rhs.str[i] && str[i] != '\0' && rhs.str[i] != '\0') {
        ++i;
    }
    return (str[i] < rhs.str[i]);
}

// Sub String from staring to ending positions
String String::substr(int start, int end) const {  
    String subString;
    int i = start;

    while(i <= end) {
        subString.str[i - start] = str[i];
        ++i;
    }

    subString.str[i - start] = '\0';

    return subString;
}

// Location of charater starting at a position
int String::findch(int start, char findMe) const {
    int i = start;
    int len = length();

    while(i <= len) {
        if(str[i] == findMe)
            return i;
        ++i;
    }
    return -1;
}

// Location of string starting at a position
int String::findstr(int start,  const String& findMe) const {
    int startI = start;
    int endI = findMe.length() - 1;
    int len = length();
    
    while(startI + endI <= len) {
        if(substr(startI, endI + startI) == findMe) {
            return startI;
        }
        ++startI;
    }
    return -1;
}

// Input, One word at a time
std::istream& operator>>(std::istream& in, String& rhs) {
    char takeIn[STRING_SIZE];

    in >> takeIn;

    rhs = takeIn;

    return in;
}

std::ostream& operator<<(std::ostream& out, const String& rhs) {
    int i = 0;
    while(rhs.str[i] != '\0') {
        out << rhs.str[i];
        ++i;
    }
    return out;
}

String operator+(String lhs, const String& rhs) {
    return lhs += rhs;
}

bool operator==(const char lhs[], const String& rhs) {
    return String(lhs) == rhs;
}

bool operator==(char lhs, const String& rhs) {
    return String(lhs) == rhs;
}

bool operator<(const char lhs[], const String& rhs) {
    return String(lhs) < rhs;
}

bool operator<(char lhs, const String& rhs) {
    return String(lhs) < rhs;
}

bool operator<=(const String& lhs, const String& rhs) {
    return (lhs == rhs || lhs < rhs);
}

bool operator!=(const String& lhs, const String& rhs) {
    return !(lhs == rhs);
}

bool operator>=(const String& lhs, const String& rhs) {
    return (lhs == rhs || lhs > rhs);
}

bool operator>(const String& lhs, const String& rhs) {
    return rhs < lhs;
}