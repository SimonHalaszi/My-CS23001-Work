/*
* Simon Halaszi
* string project
* CS23001
*/

// string.cpp for milestone 1

#include "stringM1.hpp"

// Empty string
String::String() {
    str[0] = '\0';
}

// String('x')
String::String(char ch) {
    str[0] = ch;
    str[1] = '\0';
}

// String("abcd")
String::String(const char cString[]) {
    int i = 0;
    while(cString[i] != '\0') {
        str[i] = cString[i];
        ++i;
    }
    str[i] = '\0';
}

// Max chars that can be stored
int String::capacity() const {
    return STRING_SIZE - 1;
}

// Number of char in string
int String::length() const {
    int i = 0;
    while(str[i] != '\0') {
        ++i;
    }
    return i;
}

// Accessor
char String::operator[](int index) const {  
    return str[index];
}

// Modifier
char& String::operator[](int index) {
    return str[index];
}

// Concatenation
String& String::operator+=(const String& rhs) {
    int len = length();
    int rhsLen = rhs.length();
    
    int i = len;
    while(i - len < rhsLen && rhs.str[i - len] != '\0') {
        str[i] = rhs.str[i - len];
        ++i;
    }
    str[i] = '\0';
    return *this;
}   

bool String::operator==(const String& rhs) const {
    int i = 0;
    while(str[i] == rhs.str[i] && str[i] != '\0' && rhs.str[i] != '\0') {
        ++i;
    }
    return (str[i] == rhs.str[i]);
}

bool String::operator<(const String& rhs) const {
    int i = 0;
    while(str[i] == rhs.str[i] && str[i] != '\0' && rhs.str[i] != '\0') {
        ++i;
    }
    return (str[i] < rhs.str[i]);
}

// Sub String from staring to ending positions
String String::substr(int start, int end) const {  
    String subString;

    if(end - start + 1 <= 0) {
        return subString;
    }else if(start < 0) {
        return subString;
    } else {
        int i = start;
        while(i <= end && str[i] != '\0') {
            subString[i - start] = str[i];
            ++i;
        }
        subString[i - start] = '\0';

        return subString;
    }
}

// Location of charater starting at a position
int String::findch(int start, char findMe) const {
    int i = start;
    int len = length();

    while(i <= len) {
        if(str[i] == findMe)
            return i;
        ++i;
    }
    return -1;
}

// Location of string starting at a position
int String::findstr(int start,  const String& findMe) const {
    int startI = start;
    int endI = findMe.length() - 1;
    int len = length();
    
    while(startI + endI <= len) {
        if(substr(startI, endI + startI) == findMe) {
            return startI;
        }
        ++startI;
    }
    return -1;
}

// Input, One word at a time
std::istream& operator>>(std::istream& in, String& rhs) {
    char takeIn[STRING_SIZE];

    in >> takeIn;

    rhs = takeIn;

    return in;
}

std::ostream& operator<<(std::ostream& out, const String& rhs) {
    int i = 0;
    while(rhs.str[i] != '\0') {
        out << rhs.str[i];
        ++i;
    }
    return out;
}

String operator+(String lhs, const String& rhs) {
    return lhs += rhs;
}

bool operator==(const char lhs[], const String& rhs) {
    return String(lhs) == rhs;
}

bool operator==(char lhs, const String& rhs) {
    return String(lhs) == rhs;
}

bool operator<(const char lhs[], const String& rhs) {
    return String(lhs) < rhs;
}

bool operator<(char lhs, const String& rhs) {
    return String(lhs) < rhs;
}

bool operator<=(const String& lhs, const String& rhs) {
    return (lhs == rhs || lhs < rhs);
}

bool operator!=(const String& lhs, const String& rhs) {
    return !(lhs == rhs);
}

bool operator>=(const String& lhs, const String& rhs) {
    return (lhs == rhs || lhs > rhs);
}

bool operator>(const String& lhs, const String& rhs) {
    return rhs < lhs;
}